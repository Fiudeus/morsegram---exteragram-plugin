from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Switch
from typing import Dict, Any, Optional, Tuple
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

__name__ = "Morsegram"
__description__ = "Encodes outgoing messages. Long-tap any message to decode back."
__version__ = "1.7.2"
__id__ = "morsegram"
__author__ = "@fiudeus, @ntfepsilon"
__min_version__ = "12.0.0"

# Константы

WORD_SEP = " | "
CHAR_SEP = " "
MORSE_RU_MARK = "........."
MORSE_EN_MARK = "---------"
NATO_LANG_RU_MARK = "11:11"
NATO_LANG_EN_MARK = "22:22"

# Таблица морзе

MORSE_TABLE = {
    # Латиница
    'A': '.-',    'B': '-...',  'C': '-.-.',  'D': '-..',
    'E': '.',     'F': '..-.',  'G': '--.',   'H': '....',
    'I': '..',    'J': '.---',  'K': '-.-',   'L': '.-..',
    'M': '--',    'N': '-.',    'O': '---',   'P': '.--.',
    'Q': '--.-',  'R': '.-.',   'S': '...',   'T': '-',
    'U': '..-',   'V': '...-',  'W': '.--',   'X': '-..-',
    'Y': '-.--',  'Z': '--..',

    # Кирилица
    'А': '.-',    'Б': '-...',  'В': '.--',   'Г': '--.',
    'Д': '-..',   'Е': '.',     'Ё': '.',     'Ж': '...-',
    'З': '--..',  'И': '..',    'Й': '.---',  'К': '-.-',
    'Л': '.-..',  'М': '--',    'Н': '-.',    'О': '---',
    'П': '.--.',  'Р': '.-.',   'С': '...',   'Т': '-',
    'У': '..-',   'Ф': '..-.',  'Х': '....',  'Ц': '-.-.',
    'Ч': '---.',  'Ш': '----',  'Щ': '--.-',  'Ъ': '.--.-',
    'Ы': '-.--',  'Ь': '-..-',  'Э': '..-..', 'Ю': '..--.',
    'Я': '.-.-',

    # Цифры
    '0': '-----', '1': '.----', '2': '..---', '3': '...--',
    '4': '....-', '5': '.....', '6': '-....', '7': '--...',
    '8': '---..', '9': '----.',

    # Пукнтуация
    '.': '.-.-.-',
    ',': '--..--',
    ';': '-.-.-.',
    ':': '---...',
    '/': '-..-.',
    '(': '-.--.',
    ')': '-.--.-',
    '!': '-.-.--',
    '?': '..--..',
    '_': '..--.-',
    '"': '.-..-.',
    "'": '.----.',
    '&': '.-...',
    '-': '-....-',
    '+': '.-.-.',
    '=': '-...-',
    '@': '.--.-.',
    '$': '...-..-',
}

REVERSE_MORSE_RU: Dict[str, str] = {}
REVERSE_MORSE_EN: Dict[str, str] = {}

for ch, code_raw in MORSE_TABLE.items():
    code = code_raw.strip()
    is_cyr = ("А" <= ch <= "Я") or ch in ("Ё",)
    is_lat = ("A" <= ch <= "Z")
    is_digit = ("0" <= ch <= "9")
    is_punct = not is_cyr and not is_lat and not is_digit
    if is_cyr:
        # Предпочитаем букву "Е"
        if code not in REVERSE_MORSE_RU or (REVERSE_MORSE_RU.get(code) == "Ё" and ch == "Е"):
            REVERSE_MORSE_RU[code] = ch
    if is_lat:
        if code not in REVERSE_MORSE_EN:
            REVERSE_MORSE_EN[code] = ch
    if is_punct or is_digit:
        if code not in REVERSE_MORSE_RU:
            REVERSE_MORSE_RU[code] = ch
        if code not in REVERSE_MORSE_EN:
            REVERSE_MORSE_EN[code] = ch

# NATO (Альфа/Браво/…)

NATO_RU = {
    'A': 'АЛЬФА',   'B': 'БРАВО',   'C': 'ЧАРЛИ',   'D': 'ДЕЛЬТА',
    'E': 'ЭХО',     'F': 'ФОКСТРОТ','G': 'ГОЛЬФ',   'H': 'ХОТЕЛ',
    'I': 'ИНДИЯ',   'J': 'ДЖУЛЬЕТ', 'K': 'КИЛО',    'L': 'ЛИМА',
    'M': 'МАЙК',    'N': 'НОВЕМБЕР','O': 'ОСКАР',   'P': 'ПАПА',
    'Q': 'КВЕБЕК',  'R': 'РОМЕО',   'S': 'СЬЕРРА',  'T': 'ТАНГО',
    'U': 'ЮНИФОРМ', 'V': 'ВИКТОР',  'W': 'ВИСКИ',   'X': 'ЭКС-РЭЙ',
    'Y': 'ЯНКИ',    'Z': 'ЗУЛУ',
}

# Русский NATO-алфавит: чередуем читаемые коды и числа.
# Пример: А->АЛЬФА, Б->1, В->БРАВО, Г->2, ...
RU_LETTERS = [
    'А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й',
    'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф',
    'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я',
]

NATO_RU_READABLE = [
    'АЛЬФА', 'БРАВО', 'ЧАРЛИ', 'ДЕЛЬТА', 'ЭХО', 'ФОКСТРОТ', 'ГОЛЬФ',
    'ХОТЕЛ', 'ИНДИЯ', 'ДЖУЛЬЕТ', 'КИЛО', 'ЛИМА', 'МАЙК', 'НОВЕМБЕР',
    'ОСКАР', 'ПАПА', 'КВЕБЕК', 'РОМЕО', 'СЬЕРРА', 'ТАНГО', 'ЮНИФОРМ',
    'ВИКТОР', 'ВИСКИ', 'ЭКС-РЭЙ', 'ЯНКИ', 'ЗУЛУ',
]

NATO_RU_ALT: Dict[str, str] = {}
for i, ch in enumerate(RU_LETTERS):
    NATO_RU_ALT[ch] = NATO_RU_READABLE[i // 2 % len(NATO_RU_READABLE)] if i % 2 == 0 else str((i + 1) // 2)

NATO_EN = {
    'A': 'ALPHA', 'B': 'BRAVO', 'C': 'CHARLIE', 'D': 'DELTA', 'E': 'ECHO',
    'F': 'FOXTROT', 'G': 'GOLF', 'H': 'HOTEL', 'I': 'INDIA', 'J': 'JULIETT',
    'K': 'KILO', 'L': 'LIMA', 'M': 'MIKE', 'N': 'NOVEMBER', 'O': 'OSCAR',
    'P': 'PAPA', 'Q': 'QUEBEC', 'R': 'ROMEO', 'S': 'SIERRA', 'T': 'TANGO',
    'U': 'UNIFORM', 'V': 'VICTOR', 'W': 'WHISKEY', 'X': 'X-RAY', 'Y': 'YANKEE', 'Z': 'ZULU',
}

NATO_NUM_EN = {
    '0': 'ZERO', '1': 'ONE', '2': 'TWO', '3': 'THREE', '4': 'FOUR',
    '5': 'FIVE', '6': 'SIX', '7': 'SEVEN', '8': 'EIGHT', '9': 'NINER',
}
NATO_NUM_RU = {
    '0': 'ЗИРО', '1': 'УАН', '2': 'ТУ', '3': 'СРИ', '4': 'ФОР',
    '5': 'ФАЙФ', '6': 'СИКС', '7': 'СЕВЕН', '8': 'ЭЙТ', '9': 'НАЙНЕР',
}

REVERSE_NATO: Dict[str, str] = {}
REVERSE_NATO_RU: Dict[str, str] = {}
REVERSE_NATO_EN: Dict[str, str] = {}
for k, v in NATO_RU_ALT.items():
    REVERSE_NATO_RU[v] = k
for k, v in NATO_NUM_RU.items():
    REVERSE_NATO_RU[v] = k
for k, v in NATO_EN.items():
    REVERSE_NATO_EN[v] = k
for k, v in NATO_NUM_EN.items():
    REVERSE_NATO_EN[v] = k

REVERSE_NATO.update(REVERSE_NATO_RU)
REVERSE_NATO.update(REVERSE_NATO_EN)


def _encode_unknown_char(ch: str) -> str:
    return f"U{ord(ch):X}"


def _decode_unknown_token(tok: str) -> Optional[str]:
    if len(tok) >= 2 and tok[0] == "U":
        try:
            code = int(tok[1:], 16)
            if 0 <= code <= 0x10FFFF:
                return chr(code)
        except Exception:
            return None
    return None

# RU -> LAT translit for NATO mode (сделано максимально однозначно: Й->J, Ы->Y, Э->EH, Х->KH)

RU2LAT = {
    'А': 'A',  'Б': 'B',  'В': 'V',   'Г': 'G',   'Д': 'D',
    'Е': 'E',  'Ё': 'YO', 'Ж': 'ZH',  'З': 'Z',   'И': 'I',
    'Й': 'J',  'К': 'K',  'Л': 'L',   'М': 'M',   'Н': 'N',
    'О': 'O',  'П': 'P',  'Р': 'R',   'С': 'S',   'Т': 'T',
    'У': 'U',  'Ф': 'F',  'Х': 'KH',  'Ц': 'TS',  'Ч': 'CH',
    'Ш': 'SH', 'Щ': 'SHCH','Ъ': '',   'Ы': 'Y',   'Ь': '',
    'Э': 'EH', 'Ю': 'YU', 'Я': 'YA',
}

def translit_ru_to_lat(text: str) -> str:
    out = []
    for ch in text:
        up = ch.upper()
        if up in RU2LAT:
            out.append(RU2LAT[up])
        else:
            out.append(ch)
    return "".join(out)




# Функции для UI и кодировок

def _norm_token(t: str) -> str:
    return t.strip().upper().replace("Ё", "Е")


def _has_cyrillic(text: str) -> bool:
    for ch in text:
        if ("А" <= ch <= "Я") or ("а" <= ch <= "я") or ch in ("Ё", "ё"):
            return True
    return False


def _bulletin_ok(msg: str):
    # на разных сборках могут быть разные методы
    if hasattr(BulletinHelper, "show_success"):
        run_on_ui_thread(lambda: BulletinHelper.show_success(msg))
    elif hasattr(BulletinHelper, "show_info"):
        run_on_ui_thread(lambda: BulletinHelper.show_info(msg))
    else:
        run_on_ui_thread(lambda: BulletinHelper.show_error(msg))


def _bulletin_err(msg: str):
    run_on_ui_thread(lambda: BulletinHelper.show_error(msg))


def encode_morse(text: str) -> str:
    marker = MORSE_RU_MARK if _has_cyrillic(text) else MORSE_EN_MARK
    result = []
    for word in text.upper().split():
        encoded_word = []
        for ch in word:
            code = MORSE_TABLE.get(ch)
            encoded_word.append(code if code else _encode_unknown_char(ch))
        result.append(CHAR_SEP.join(encoded_word))
    payload = WORD_SEP.join(result)
    return marker + WORD_SEP + payload if payload else marker


def decode_morse(text: str) -> str:
    lang = None
    body = text
    if WORD_SEP in text:
        first, rest = text.split(WORD_SEP, 1)
        first = first.strip()
        if first == MORSE_RU_MARK:
            lang = "ru"
            body = rest
        elif first == MORSE_EN_MARK:
            lang = "en"
            body = rest
    reverse = REVERSE_MORSE_RU if lang == "ru" else REVERSE_MORSE_EN if lang == "en" else REVERSE_MORSE_RU
    result = []
    for word in body.split(WORD_SEP):
        decoded_word = []
        for sym in word.strip().split(CHAR_SEP):
            sym = sym.strip()
            if not sym:
                continue
            escaped = _decode_unknown_token(sym)
            decoded_word.append(escaped if escaped is not None else reverse.get(sym, sym))
        result.append("".join(decoded_word))
    return " ".join(result).strip()


def is_morse(text: str) -> bool:
    s = text.strip()
    if not s:
        return False
    if WORD_SEP in s:
        first = s.split(WORD_SEP, 1)[0].strip()
        if first in (MORSE_RU_MARK, MORSE_EN_MARK):
            return True
    return all(c in ".- |" for c in s) and ("." in s or "-" in s)


def encode_nato(text: str) -> str:
    is_ru = _has_cyrillic(text)
    marker = NATO_LANG_RU_MARK if is_ru else NATO_LANG_EN_MARK
    result = []
    for word in text.upper().split():
        encoded_word = []
        for ch in word:
            if is_ru and ch in NATO_RU_ALT:
                encoded_word.append(NATO_RU_ALT[ch])
            elif is_ru and ch in NATO_NUM_RU:
                encoded_word.append(NATO_NUM_RU[ch])
            elif not is_ru and ch in NATO_EN:
                encoded_word.append(NATO_EN[ch])
            elif not is_ru and ch in NATO_NUM_EN:
                encoded_word.append(NATO_NUM_EN[ch])
            else:
                encoded_word.append(_encode_unknown_char(ch))
        result.append(CHAR_SEP.join(encoded_word))
    payload = WORD_SEP.join(result)
    return marker + WORD_SEP + payload if payload else marker


def decode_nato(text: str) -> str:
    lang = None
    body = text
    if WORD_SEP in text:
        first, rest = text.split(WORD_SEP, 1)
        first = _norm_token(first)
        if first == NATO_LANG_RU_MARK:
            lang = "ru"
            body = rest
        elif first == NATO_LANG_EN_MARK:
            lang = "en"
            body = rest

    reverse = REVERSE_NATO_RU if lang == "ru" else REVERSE_NATO_EN if lang == "en" else REVERSE_NATO
    result = []
    for word in body.split(WORD_SEP):
        decoded_word = []
        for tok in word.strip().split(CHAR_SEP):
            tok = _norm_token(tok)
            if not tok:
                continue
            escaped = _decode_unknown_token(tok)
            decoded_word.append(escaped if escaped is not None else reverse.get(tok, tok))
        result.append("".join(decoded_word))
    return " ".join(result)


def is_nato(text: str) -> bool:
    s = text.strip()
    if not s:
        return False
    tokens = [_norm_token(t) for t in s.replace("|", " ").split() if t.strip()]
    if not tokens:
        return False
    if tokens[0] in (NATO_LANG_RU_MARK, NATO_LANG_EN_MARK):
        return True
    known = sum(1 for t in tokens if t in REVERSE_NATO)
    return known >= 2 and known >= max(2, len(tokens) // 2)


def detect_codec(text: str) -> Optional[str]:
    if is_morse(text):
        return "morse"
    if is_nato(text):
        return "nato"
    return None


def encode_by_codec(codec: str, text: str) -> str:
    return encode_morse(text) if codec == "morse" else encode_nato(text)


def decode_by_codec(codec: str, text: str) -> str:
    return decode_morse(text) if codec == "morse" else decode_nato(text)


def parse_prefix(original: str) -> Tuple[Optional[str], str]:
    """
    Префиксы:
      !m   -> Morse
      !n   -> NATO
      !raw -> Не кодировать
    """
    s = original.lstrip()
    low = s.lower()
    if low.startswith("!raw "):
        return ("raw", s[5:])
    if low.startswith("!m "):
        return ("morse", s[3:])
    if low.startswith("!n "):
        return ("nato", s[3:])
    return (None, original)


def get_drawer_menu_type() -> Optional[Any]:
    if hasattr(MenuItemType, "DRAWER_MENU"):
        return MenuItemType.DRAWER_MENU
    candidates = [
        "LEFT_MENU",
        "LEFT_DRAWER",
        "MAIN_MENU",
        "MAIN_DRAWER",
        "SIDE_MENU",
        "NAVIGATION_DRAWER",
    ]
    for name in candidates:
        if hasattr(MenuItemType, name):
            return getattr(MenuItemType, name)
    return None


# Сам плагин

class MorseCodePlugin(BasePlugin):

    def on_plugin_load(self):
        self.add_on_send_message_hook()

        # Кнопка в контекстном меню сообщений для декодирования
        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text="Decode",
                subtext="Decode Morse / NATO",
                icon="msg_info",
                item_id="morsegram_decode_btn",
                on_click=self._on_decode_click,
            )
        )

        # Кнопки в левом меню (если есть) для быстрого доступа к настройкам и включению/выключению
        drawer_type = get_drawer_menu_type()
        if drawer_type is not None and self.get_setting("drawer_buttons", True):
            self._drawer_toggle_item = self.add_menu_item(
                MenuItemData(
                    menu_type=drawer_type,
                    text="Morsegram: ON/OFF",
                    subtext="Toggle plugin",
                    icon="settings",
                    item_id="morsegram_toggle",
                    on_click=self._on_left_toggle_click,
                )
            )
            self._drawer_settings_item = self.add_menu_item(
                MenuItemData(
                    menu_type=drawer_type,
                    text="Morsegram Settings",
                    subtext="Open plugin settings",
                    icon="settings",
                    item_id="morsegram_settings",
                    on_click=self._on_left_settings_click,
                )
            )
        else:
            self._drawer_toggle_item = None
            self._drawer_settings_item = None

        self.log("Morsegram plugin loaded!")

    def on_plugin_unload(self):
        self._remove_drawer_items()
        self.log("Morsegram plugin unloaded!")

    # Хуки

    def _extract_outgoing_text(self, params: Any) -> Tuple[Optional[str], Optional[str]]:
        for field in ("message", "caption", "messageText", "text"):
            if hasattr(params, field):
                value = getattr(params, field)
                if isinstance(value, str):
                    return field, value
        return None, None

    def _set_outgoing_text(self, params: Any, field: Optional[str], value: str) -> bool:
        if not field:
            return False
        try:
            setattr(params, field, value)
            return True
        except Exception:
            return False

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not self.get_setting("enabled", True):
            return HookResult()

        text_field, original = self._extract_outgoing_text(params)
        if not text_field or original is None:
            return HookResult()

        trimmed = original.strip()
        if not trimmed:
            return HookResult()

        # Защита от двойной кодировки (если включена)
        if self.get_setting("skip_if_encoded", True) and detect_codec(trimmed):
            return HookResult()

        prefix_only = self.get_setting("prefix_only", False)
        default_codec = "nato" if self.get_setting("default_nato", False) else "morse"
        ru_to_nato = self.get_setting("ru_to_nato", False)

        pref_codec, no_pref_text = parse_prefix(original)

        if pref_codec == "raw":
            if self._set_outgoing_text(params, text_field, no_pref_text):
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            return HookResult()

        if prefix_only and pref_codec is None:
            return HookResult()

        codec = pref_codec if pref_codec in ("morse", "nato") else default_codec
        payload = no_pref_text if pref_codec else original
        payload = payload.strip()

        # RU -> NATO
        if codec == "nato" and ru_to_nato:
            payload = translit_ru_to_lat(payload)

        encoded = encode_by_codec(codec, payload)
        self.log(f"Encode[{codec}] ({text_field}): '{payload}' -> '{encoded}'")
        if not self._set_outgoing_text(params, text_field, encoded):
            return HookResult()
        return HookResult(strategy=HookStrategy.MODIFY, params=params)

    # Декодировка

    def _on_decode_click(self, context: Dict[str, Any]):
        message = context.get("message")
        if not message:
            return

        text = str(message.messageText) if getattr(message, "messageText", None) else ""
        if not text.strip():
            _bulletin_err("Message is empty")
            return

        codec = detect_codec(text)
        if not codec:
            _bulletin_err("Not Morse / NATO text")
            return
        decoded = decode_by_codec(codec, text)

        self.log(f"Decode[{codec}]: '{text}' -> '{decoded}'")

        def show_dialog():
            fragment = get_last_fragment()
            if not fragment or not (activity := fragment.getParentActivity()):
                return

            dialog = AlertDialogBuilder(activity)
            dialog.set_title("Morsegram")
            dialog.set_message(
                f"Detected: {codec}\n\n"
                f"Encoded:\n{text}\n\n"
                f"Decoded:\n{decoded}"
            )
            dialog.set_positive_button("OK", lambda d, w: d.dismiss())
            dialog.show()

        run_on_ui_thread(show_dialog)

    #Удаление/добавление кнопок

    def _remove_drawer_items(self):
        try:
            if getattr(self, "_drawer_toggle_item", None):
                self.remove_menu_item(self._drawer_toggle_item)
                self._drawer_toggle_item = None
            if getattr(self, "_drawer_settings_item", None):
                self.remove_menu_item(self._drawer_settings_item)
                self._drawer_settings_item = None
        except Exception:
            pass

    def _add_drawer_items(self):
        drawer_type = get_drawer_menu_type()
        if drawer_type is None:
            return
        if getattr(self, "_drawer_toggle_item", None) or getattr(self, "_drawer_settings_item", None):
            return

        self._drawer_toggle_item = self.add_menu_item(
            MenuItemData(
                menu_type=drawer_type,
                text="Morsegram: ON/OFF",
                subtext="Toggle plugin",
                icon="settings",
                item_id="morsegram_toggle",
                on_click=self._on_left_toggle_click,
            )
        )
        self._drawer_settings_item = self.add_menu_item(
            MenuItemData(
                menu_type=drawer_type,
                text="Morsegram Settings",
                subtext="Open plugin settings",
                icon="settings",
                item_id="morsegram_settings",
                on_click=self._on_left_settings_click,
            )
        )

    def _on_drawer_buttons_change(self, enabled: bool):
        def do():
            if enabled:
                self._add_drawer_items()
            else:
                self._remove_drawer_items()

        run_on_ui_thread(do)

    # Меню слева

    def _on_left_toggle_click(self, _context: Dict[str, Any]):
        current = self.get_setting("enabled", True)
        new_value = not current

        ok = False
        try:
            if hasattr(self, "set_setting"):
                self.set_setting("enabled", new_value)
                ok = True
        except Exception:
            ok = False

        if ok:
            _bulletin_ok(f"Morsegram {'enabled' if new_value else 'disabled'}")
        else:
            _bulletin_err("Can't toggle (set_setting not available in this build)")

    # Меню слева - открыть настройки

    def _on_left_settings_click(self, _context: Dict[str, Any]):
        def open_settings():
            try:
                fragment = get_last_fragment()
                if not fragment:
                    BulletinHelper.show_error("Can't open settings (no fragment)")
                    return

                java_plugin = PluginsController.getInstance().plugins.get(self.id)
                if not java_plugin:
                    BulletinHelper.show_error("Can't open settings (plugin not found)")
                    return

                fragment.presentFragment(PluginSettingsActivity(java_plugin))
            except Exception:
                BulletinHelper.show_error("Failed to open settings")

        run_on_ui_thread(open_settings)

    # Настройки

    def create_settings(self):
        return [
            Header(text="Morsegram"),
            Switch(
                key="enabled",
                text="Enable encoding",
                default=True,
                subtext="Encodes outgoing messages (Morse / NATO)",
                icon="msg_text",
            ),
            Switch(
                key="prefix_only",
                text="Prefix-only mode",
                default=False,
                subtext="Encode only if message starts with !m or !n (use !raw to bypass)",
                icon="msg_info",
            ),
            Switch(
                key="default_nato",
                text="Default codec: NATO (Alpha/Bravo/Charlie)",
                default=False,
                subtext="If disabled, default codec is Morse",
                icon="msg_info",
            ),
            Switch(
                key="ru_to_nato",
                text="RU → NATO mode",
                default=False,
                subtext="Transliterates Russian letters to Latin before NATO encoding (e.g. ПРИВЕТ -> PRIVET -> NATO)",
                icon="msg_info",
            ),
            Switch(
                key="skip_if_encoded",
                text="Skip if already encoded",
                default=True,
                subtext="Prevents double-encoding if message looks like Morse/NATO already",
                icon="msg_info",
            ),
            Switch(
                key="drawer_buttons",
                text="Drawer buttons",
                default=True,
                subtext="Show Morsegram buttons in the left menu (toggle/settings)",
                icon="msg_settings_14",
                on_change=self._on_drawer_buttons_change,
            ),
        ]
